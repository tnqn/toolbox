package main

import (
	"bufio"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"

	"github.com/gobwas/glob"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var skipFile = errors.New("skip this file")

func main() {
	cmd := newCommand()
	if err := cmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error running code-line: %v\n", err)
		os.Exit(1)
	}
}

type options struct {
	dir                     string
	excludedNamePatterns    []string
	excludedContentPatterns []string
	longest                 int
}

type fileStat struct {
	file  string
	lines int
}

type byLines []*fileStat

func (p byLines) Len() int {
	return len(p)
}
func (p byLines) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}
func (p byLines) Less(i, j int) bool {
	return p[i].lines > p[j].lines
}

func newOption() *options {
	return &options{
		dir:     ".",
		longest: 10,
		excludedNamePatterns: []string{
			".git",
		},
		excludedContentPatterns: []string{
			"// Code generated by *",
		},
	}
}

func (o *options) AddFlags(fs *pflag.FlagSet) {
	fs.StringVar(&o.dir, "dir", o.dir, "The directory in which code lines will be counted")
	fs.IntVar(&o.longest, "longest", o.longest, "Print file names of the N longest file")
	fs.StringArrayVar(&o.excludedNamePatterns, "exclude-name", o.excludedNamePatterns, "The pattern of file/dir names to exclude")
	fs.StringArrayVar(&o.excludedContentPatterns, "exclude-content", o.excludedContentPatterns, "The pattern of line content to match, the whole file will be excluded once matched")
}

func newCommand() *cobra.Command {
	o := newOption()
	cmd := &cobra.Command{
		Use: "code-line [--dir PATH] [--exclude-name FILENAME] [--exclude-content FILECONTENT] [--longest N]",
		Example: `code-line --dir ./ --exclude-name .git --exclude-name .cache --exclude-content "// Code generated by *"
`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return run(o)
		},
	}
	flags := cmd.Flags()
	o.AddFlags(flags)
	return cmd
}

func run(o *options) error {
	var excludedNamePatterns, excludedContentPatterns []glob.Glob
	for _, name := range o.excludedNamePatterns {
		g, err := glob.Compile(name)
		if err != nil {
			return err
		}
		excludedNamePatterns = append(excludedNamePatterns, g)
	}

	for _, content := range o.excludedContentPatterns {
		g, err := glob.Compile(content)
		if err != nil {
			return err
		}
		excludedContentPatterns = append(excludedContentPatterns, g)
	}

	totalLines := 0
	var skippedDirs, skippedFiles []string
	var fileStats []*fileStat

	if err := filepath.WalkDir(o.dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if matchAny(d.Name(), excludedNamePatterns) {
			if d.IsDir() {
				skippedDirs = append(skippedDirs, path)
				return filepath.SkipDir
			} else {
				skippedFiles = append(skippedFiles, path)
				return nil
			}
		}
		if d.IsDir() {
			return nil
		}
		lines, err := countLines(path, excludedContentPatterns)
		if err != nil {
			if errors.Is(err, skipFile) {
				skippedFiles = append(skippedFiles, path)
				return nil
			}
			return err
		}
		fmt.Fprintf(os.Stderr, "File: %s - lines: %d\n", path, lines)
		totalLines += lines
		fileStats = append(fileStats, &fileStat{
			file:  path,
			lines: lines,
		})
		return nil
	}); err != nil {
		return err
	}
	for _, dir := range skippedDirs {
		fmt.Fprintf(os.Stderr, "Dir: %s - skipped\n", dir)
	}
	for _, file := range skippedFiles {
		fmt.Fprintf(os.Stderr, "File: %s - skipped\n", file)
	}
	sort.Sort(byLines(fileStats))
	for i := 0; i < o.longest; i++ {
		if i >= len(fileStats) {
			break
		}
		fmt.Fprintf(os.Stderr, "Longest file #%d: %s - lines: %d\n", i, fileStats[i].file, fileStats[i].lines)
	}

	fmt.Fprintf(os.Stdout, "Total lines: %d\n", totalLines)
	return nil
}

func matchAny(s string, globs []glob.Glob) bool {
	for _, g := range globs {
		if g.Match(s) {
			return true
		}
	}
	return false
}

func countLines(filename string, globs []glob.Glob) (int, error) {
	file, err := os.Open(filename)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lines := 0
	for scanner.Scan() {
		if matchAny(scanner.Text(), globs) {
			return 0, skipFile
		}
		lines++
	}
	return lines, nil
}
